#Penjelasan singkat python-search.py
Percobaan 10 Binary Search_Rotation, carilah rotasi terkecil dalam daftar rotasi. Kita mulai dengan menentukan rendah (indeks pertama dalam daftar) dan tinggi (indeks terakhir dalam daftar). Pada while loop, kita menghitung indeks menengah (mid) dengan menggunakan operator pembagian lantai // pada penjumlahan low dan high. Kami membandingkan elemen pada indeks dengan elemen dengan indeks lebih tinggi. Jika data[mid] lebih besar dari data[high], berarti titik rotasi berada di kanan tengah. Jadi kami memperbarui low = mid + 1 untuk menemukan sisi kanan mid . Jika data[mid] tidak lebih besar dari data[high], berarti titik rotasi berada di sebelah kiri mid atau mid itu sendiri merupakan indeks rotasi terkecil. Dalam hal ini, kami memperbarui high = mid untuk mencari di sebelah kiri mid. Siklus berlanjut selama yang rendah lebih kecil dari yang tinggi. Setelah loop berakhir, nilai rendah akan menjadi indeks rotasi terkecil. 
Percobaan 11 Pencarian Biner_Paling Sering, menemukan elemen paling sering dalam daftar yang diurutkan. Variabel max_count digunakan untuk melacak jumlah kemunculan maksimum dari elemen yang paling sering muncul. Variabel most_frequent digunakan untuk menyimpan elemen yang paling sering muncul. Kami pertama-tama menentukan rendah (indeks pertama dalam daftar) dan tinggi (indeks terakhir dalam daftar). Pada while loop, kita menggunakan operator pembagian bawah // untuk menghitung indeks tengah (mid) pada penjumlahan low dan high. Kami menginisialisasi hitung ke 1 untuk menghitung jumlah kemunculan elemen pada pertengahan indeks. Kami memeriksa elemen di kiri dan kanan tengah dan menghitung jumlah kemunculan yang identik. Masih sama dengan elemen pada index mid, selama count lebih besar dari max_count,dengan elemen count dan most_frequent dengan indeks mid. Jika count sama dengan 1, berarti elemen pada index mid tidak memiliki kejadian lain dalam daftar, jadi kita keluar dari loop. Jika masih ada kemungkinan elemen yang sama di sebelah kiri, kita perbarui indeks dari tinggi ke kiri. Jika ada kemungkinan elemen yang sama di sebelah kanan, kami perbarui rendah menjadi indeks di sebelah kanan. Selama low kurang dari atau sama dengan high, while loop akan terus berlanjut. Setelah perulangan berakhir, nilai most_frequent akan berisi elemen yang paling sering muncul dalam daftar. Kami mengembalikan most_frequent sebagai hasil dan mencetaknya.
Percobaan 12 Binary Search_Name List, untuk mencari data dalam daftar terurut. Pertama, kami memastikan bahwa rendah adalah indeks pertama dalam daftar dan tinggi adalah indeks terakhir dalam daftar. Pada perulangan while, kita menggunakan operator pembagian lantai // pada low dan high. Jika elemen pada index mid sama dengan target yang kita cari, maka kita langsung mengembalikan nilai mid sebagai index yang sesuai. Jika elemen pada index mid kurang dari target, maka targetnya adalah mid-right. Oleh karena itu, kami mengupdate low = mid + 1 untuk mencari di sebelah kanan mid, dan jika elemen pada index mid lebih besar dari target, berarti target berada di sebelah kiri mid. Dalam hal ini kami mengupdate high = mid - 1 untuk mencari di sebelah kiri mid . Perulangan while berlanjut selama low kurang dari atau sama dengan high. Jika perulangan berakhir dan kita belum menemukan target, kita mengembalikan -1 untuk menunjukkan bahwa target tidak ditemukan dalam daftar. Setelah keluar dari loop, kami mencetak pesan yang sesuai berdasarkan hasil pencarian.
